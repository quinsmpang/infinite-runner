/* * Playdom, Inc. (c)2013 All Rights Reserved */ package com.playdom.gas.parsing  { 	import com.playdom.common.util.trimString;

	/**	 * Tokenizes a GasScript script.  GasScript uses indents to determine 	 * child/parent relationships; children are indented below their parent.	 * 	 * @author Rob Harris	 */	public class GasScriptTokenizer extends ScriptTokenizer	{		/** The data object resulting from the parse. */		private var dataObj:Object;				/** The current list of children. */		private var currChildren:Array;				/** The current indent level. */		private var currIndent:int;				/** The current data object. */		private var currObj:Object;				/** The object stack. */		private var objStack:Array = new Array();				/**		 * The script format type.		 */		override public function get formatType():String		{			return "GAS";		}				/**		 * The source string to be parsed.		 */		override public function set source(txt:String):void		{			try			{				convert(txt);			}			catch (err:Error)			{				log.error(".set source: GasScript parse failed: "+err.message, this);			}		}				/**		 * Converts a string to a data object.		 * 		 * @param txt The string to be converted.		 */		private function convert(txt:String):void		{			if (txt)			{				initParse();				var lines:Array = txt.split("\n");				for (var i:int = 0; i < lines.length; i++)				{	// parse each line					var line:String = lines[i];					if (line.length > 0)						// skip blank line					{						var indent:int = parseIndent(line);						if (line.indexOf("//") != indent)		// skip comments						{							line = trimString( line );							if (line.length > 0)				// skip blank line							{								var tag:String = parseTag(line);								if (indent > currIndent)		// start children								{									indentIncreased(tag, indent);								}								else if (indent == currIndent)	// more children								{									currChildren.push(currObj = {tag:tag});								}								else							// end of children								{									indentDecreased(tag, indent);								}								// add attributes to the data object								parseAttributes(line, currObj);							}						}					}				}				cleanUpStack();			}		}				/**		 * Prepares for parsing.		 */		private function initParse():void		{			currIndent = -1;//			currIndent = 0;//			currChildren = new Array();			dataObj = {tag:"data", children:currChildren};			currObj = dataObj;		}				/**		 * Starts adding children.		 */		private function indentIncreased(tag:String, indent:int):void		{			// push the parent on to the stack			pushStack(currObj, indent);							// set the indent level			currIndent = indent;								// create an array for the children			currChildren = currObj.children = new Array();						// create the first child			currChildren[0] = currObj = {tag:tag};		}				/**		 * Stops adding children.		 */		private function indentDecreased(tag:String, indent:int):void		{			// pop the object stack to find a matching indent			var popIndent:int = popStack();			while (indent != popIndent && objStack.length > 0)			{				popIndent = popStack();			}			// push the matching parent back on to the stack			pushStack(currObj, indent);							// set the current indent and array of children			currIndent = indent;			currChildren = currObj.children;						// create new child of matching parent			currChildren.push(currObj = {tag:tag});		}				/**		 * Pushes a data object on to the stack while storing the indent level.		 * 		 * @param dataObj The data object.		 * @param indent  The indent level.		 */		private function pushStack(dataObj:Object, indent:int):void		{			currObj.$indent$ = indent;	// store the indent level in a temporary property			objStack.push(currObj);		// push the parent on to the stack		}				/**		 * Pops a data object from the stack and returns the indent level.		 */		private function popStack():int		{			currObj = objStack.pop();			var indent:int = currObj.$indent$;			delete currObj.$indent$;			return indent;		}				/**		 * Gets the tag from a line.		 * 		 * @param line  The line containing the tag.		 * 		 * @return  The tag. 		 */		private function parseTag(line:String):String		{			var idx:int = line.indexOf(" ");			if (idx == -1)			{	// tag only - no attributes				return line;			}			else			{	// separate tag from attributes				return line.substring(0, idx);			}		}				/**		 * Fetches the indent for a line by counting the spaces.		 *  		 * @param line  The line to be scanned.		 * 		 * @return  The number of leading spaces. 		 */		private function parseIndent(line:String):int		{			for (var i:int = 0; i < line.length; i++)			{				if (line.charAt(i) != " ")				{					return i;				}			}			return i;		}				/**		 * Parse a line for attributes and stores the key/value pair in a data object.		 *  		 * @param line  The line to be parsed.		 * @param data The data object.		 */		private function parseAttributes(line:String, data:Object):void		{			var keyStart:int = line.indexOf(" ")+1;					while (keyStart < line.length)			{				var keyEnd:int = line.indexOf("=", keyStart+1);				var valStart:int = line.indexOf("'", keyEnd);				if (valStart == keyEnd+1)				{	// quoted					valStart++;					var valEnd:int = line.indexOf("'", valStart+1);							var gapInc:int = 2;				}				else if (keyEnd != -1)				{	// not quoted					valStart = keyEnd+1;					valEnd = line.indexOf(" ", valStart+1);							gapInc = 1;				}				else				{	// found junk at end of line					break;				}				if (valEnd == -1)				{					valEnd = line.length;				}				var key:String = line.substring(keyStart, keyEnd);				var value:String = line.substring(valStart, valEnd);				data[key] = value;				keyStart = valEnd+gapInc;			}		}				/**		 * Cleans up the object stack.		 */		private function cleanUpStack():void		{			while (objStack.length > 0)			{				currObj = objStack.pop();				delete currObj.$indent$;			}		}				/**		 * Creates a tokenizer instance and associates it with XML data.		 *  		 * @param xml The associated XML data.		 * 		 * @return The new instance. 		 */		private function makeTokenizer(jsonObj:Object):ScriptTokenizer		{			var tokenizer:GasScriptTokenizer = new GasScriptTokenizer();			tokenizer.init(animVars, log);			tokenizer.dataObj = jsonObj;			return tokenizer;		}				/**		 * Frees all resources for garbage collection.		 */		override public function destroy():void		{			super.destroy();			dataObj = null;		}				/**		 * Fetches the tag name for this tokenizer.		 *  		 * @return The tag name. 		 */		override public function getTag():String		{			return dataObj["tag"];		}				/**		 * Fetches the value associated with an attribute key.		 *  		 * @param key The attribute key.		 * 		 * @return The associated value. 		 */		override public function getAttribute(key:String):String		{			return dataObj[key];		}				/**		 * Fetches the number of children belonging to this tokenizer.		 *  		 * @return The number of children. 		 */		override public function getNumChildren():int		{			return dataObj.children ? dataObj.children.length : 0;		}				/**		 * Fetches an array of tokenizers where each is a child of this tokenizer.		 *  		 * @return The array of children tokenizers. 		 */		override public function getChildren():Array		{			var children:Array = dataObj.children;			var arr:Array = [];			var i:int = 0;			for each (var child:Object in children)			{				arr[i++] = makeTokenizer(child);			}			return arr;		}			}}